##### B+树和skipList的时间复杂度都是O(logn)，为什么数据库底层要用B+树而不用skipList?

因为B+tree比跳跃表的检索效率更高，数据分部的更均匀。

跳跃表是通过二路分治的方式实现logN。
B+Tree是通过多路分治的方式实现logN。

当数据表的数据足够多的时候，B+tree的根节点～任何一块叶子节点的路径是固定的。而skiplist的头节点～目标节点的路径是不固定的。所以检索的value越大，skiplist的路径就越深，磁盘的io次数就越多。

B+tree的所有叶子节点构成了一个双向循环链表，每一块叶子节点可以存储一条或者多条数据。这种结构不管是一条记录、还是多条记录查询都能节省磁盘IO。

skiplist的每一个节点只存储一条记录，对于一条记录的查询是比较节省磁盘io，对于多条记录的查询，skiplist的磁盘IO次数会比B+tree要多。

##### mysql 索引为什么用b+树不用哈希表

哈希表是一种 key-value 形式的数据结构，底层采用数组+链表结构来实现，它是将 key 通过一个哈希函数计算出一个数字，然后以该数字作为数组的下标，然后将 value 存放到对应下标的数组中。对于不同的 key，在经过哈希函数计算后，可能出现相同的值，这种情况叫做哈希冲突，这时候就意味着同一个数组下标处要存放两个元素了，所以这个时候将数组中的元素变为一个链表，通过链表将这两个元素串联起来。

根据上面哈希表的特点来看，哈希表对于删除、查找、更新、插入操作，都是先根据 key 计算出一个值，就能定位到数据的目标位置了，时间复杂度都是 O(1)，速度特别快。但是我们在使用 MySQL 时，经常会遇到查找某个范围内的数据，例如 between...and、>=、<=等范围查找操作。这个时候哈希表应该怎么办呢？

因为哈希表的所有 key 都会经过哈希函数计算，然后再存放数据，本来可能有序的 key，但经过哈希函数计算出来的值就不是有序的了，所以这个时候，如果要在哈希表中进行范围查找，就只能对整个哈希表进行遍历了，只有符合条件范围的数据，才取出来。当我们数据库中的数据越来越多，达到几百万甚至几千万条的时候，这个时候，对整个表的遍历是非常耗时的。

因此，从范围查询的场景来看，哈希表也不太适合作为 MySQL 索引的数据结构。

需要注意的是mysql的索引不用哈希表只是InnoDB引擎默认用B+树作为索引，memory引擎是用哈希表作为索引的。